<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[test3]]></title>
      <url>http://yoursite.com/2016/06/16/test3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>加油学习~奋斗  第3个</p>
</blockquote>
<ul>
<li>什么被你轻视了，终会被你重视，专注于一个方向，你终究会比别人走的更远！<ul>
<li>直接把一个markdown的文本文件拖放到当前这个页面就可以了</li>
<li>导出为一个html格式的文件，样式一点也不会丢失</li>
</ul>
</li>
<li>编辑和预览<code>同步滚动</code>，所见即所得（右上角设置） </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[菜鸟笔记--js数据类型及判别]]></title>
      <url>http://yoursite.com/2016/06/15/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%88%A4%E5%88%AB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>加油学习~奋斗</p>
</blockquote>
<h2 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h2><p>5种基本数据类型：<code>Undefined、Null、Boolean、Number、String</code>。<br>还有一种复杂的数据类型Object，Object本质是一组无序的名值对组成的。<br><a id="more"></a></p>
<ul>
<li><code>Undefined</code>类型只有一个值:即undefined，使用var声明变量，但是未对初始化的，这个变量就是Undefined类型的，undefined值是派生自null值的，所以undefined==null</li>
<li><code>Null</code>类型也只有一个值:null值表示一个空对象的指针。</li>
<li><code>Boolean</code>类型：只有两个字面值true和false。但是js中多有的变量都可以使用Boolean()函数转换成一个Boolean类型的值。</li>
<li><code>Number</code>类型：整数和浮点数。NaN是一个特殊的数值,NaN的特点：<br>1、任何涉及NaN的操作都会返回NaN。<br>2、NaN对任何值都不相等，包括自己NaN本身。<br>针对NaN特性，JS内置了isNaN()函数，来确定数值是不是NaN类型。</li>
</ul>
<h2 id="js数据类型判别"><a href="#js数据类型判别" class="headerlink" title="js数据类型判别"></a>js数据类型判别</h2><ul>
<li><p><code>typeof</code>操作符：对一个变量进行检测变量的类型，用法：typeof 123; 或者 typeof(123); 会返回”number”<br><code>用typeof判断基本类型</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>;<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object  ,这是因为特殊值null被认为是一个空的对象引用。</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span>; <span class="comment">//string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// number ,NaN非数值是一个特殊的数值。 这个数值用来表示一个本来要返回数值的操作数未返回数值的情况。</span></span><br></pre></td></tr></table></figure>
<p><code>用typeof判断引用类型</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> /\d/ <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>使用typeof判断引用型数据除了function以外都是object，还有就是typeof在一些低版本中检测正则会返回function</p>
</li>
<li><p><code>instanceof</code>用于判断一个变量是否是某个对象的实例，和typeof最实质上的区别—是一个三目运算式，如果变量是给定引用类型的实例，那么instanceof操作符就会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[];</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">//返回true</span></span><br><span class="line"><span class="number">123</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>; <span class="comment">// 返回false ，123是基本数据类型</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">123</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span>; <span class="comment">//返回false，因为Number（123）调用Number函数。结果是 一个数值属于是基本数据类型，所以false。</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span>;<span class="comment">//true，因为这里new创建了一个Number的实例，是一个对象</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true         </span></span><br><span class="line">(<span class="regexp">/\d/</span>) <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>;<span class="comment">//true </span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>;  <span class="comment">//true                </span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="keyword">instanceof</span> <span class="built_in">Date</span> ; <span class="comment">//true   </span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>instanceof 操作符检测基本类型的值都会返回false，instanceof 后面一定要是对象类型，并且大小写不能错</p>
</li>
<li><p><code>constructor</code> 返回对象相应的构造函数，效果与instanceof一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span>.constructor == <span class="built_in">Boolean</span>;<span class="comment">//true</span></span><br><span class="line">[].constructor == <span class="built_in">Array</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>使用instaceof和construcor,被判断的array必须是在当前页面声明的！比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false；<br>原因：<br>1、array属于引用型数据，在传递过程中，仅仅是引用地址的传递。<br>2、每个页面的Array原生对象所引用的地址是不一样的，在子页面声明的array，所对应的构造函数，是子页面的Array对象；父页面来进行判断，使用的Array并不等于子页面的Array；切记，不然很难跟踪问题！</p>
</li>
<li><code>Object.prototype.toString.call( )</code> Obeject原型上的toString方法,都会返回一个[object NativeConstructorName]格式的字符串。这是一种较准确的判断数据类型的方法，可以区分对象，数组和null<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">123</span>);<span class="comment">//[object Number]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还有其他的就不太了解了</p>
]]></content>
    </entry>
    
  
  
</search>
